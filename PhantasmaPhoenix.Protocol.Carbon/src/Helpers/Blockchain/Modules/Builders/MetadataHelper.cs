using System.Collections;
using System.Numerics;
using PhantasmaPhoenix.Core.Extensions;
using PhantasmaPhoenix.Protocol.Carbon;
using PhantasmaPhoenix.Protocol.Carbon.Blockchain.Vm;

namespace PhantasmaPhoenix.Protocol.Carbon.Blockchain.Modules.Builders;

public sealed class MetadataField
{
	public MetadataField(string name, object? value)
	{
		Name = name;
		Value = value;
	}

	public string Name { get; set; }
	public object? Value { get; set; }
}

public readonly struct FieldType
{
	public FieldType(string name, VmType type)
	{
		Name = name;
		Type = type;
	}

	public string Name { get; }
	public VmType Type { get; }
}

public static class MetadataHelper
{
	private static readonly BigInteger Int64Min = new(long.MinValue);
	private static readonly BigInteger Int64Max = new(long.MaxValue);
	private static readonly BigInteger UInt64Max = (BigInteger.One << 64) - 1;
	private static readonly BigInteger Int256Min = -(BigInteger.One << 255);
	private static readonly BigInteger Int256Max = (BigInteger.One << 255) - 1;
	private static readonly BigInteger UInt256Max = (BigInteger.One << 256) - 1;

	public static readonly FieldType[] SeriesDefaultMetadataFields =
	{
		new FieldType(StandardMeta.id.data, VmType.Int256), // Mandatory field, autogenerated by SDK
		new FieldType("mode", VmType.Int8), // Phantasma feature: Unique or duplicate series type
		new FieldType("rom", VmType.Bytes) // Phantasma feature: If this is a duplicated series, store the duplicated ROM here
	};

	public static readonly FieldType[] NftDefaultMetadataFields =
	{
		new FieldType(StandardMeta.id.data, VmType.Int256), // Mandatory field, autogenerated by SDK
		new FieldType("rom", VmType.Bytes) // Phantasma feature: If this is NOT a duplicated series, store the individual ROM here
	};

	public static readonly FieldType[] StandardMetadataFields =
	{
		new FieldType("name", VmType.String),
		new FieldType("description", VmType.String),
		new FieldType("imageURL", VmType.String),
		new FieldType("infoURL", VmType.String),
		new FieldType("royalties", VmType.Int32)
	};

	public static MetadataField? FindMetadataField(IReadOnlyList<MetadataField> fields, string name)
	{
		return fields.FirstOrDefault(f => string.Equals(f.Name, name, StringComparison.OrdinalIgnoreCase));
	}

	public static byte[] GetOptionalBytesField(IReadOnlyList<MetadataField> fields, string name)
	{
		var found = FindMetadataField(fields, name);
		if (found == null)
		{
			return Array.Empty<byte>();
		}

		return EnsureBytes(name, found.Value);
	}

	public static void PushMetadataField(
		VmNamedVariableSchema fieldSchema,
		List<VmNamedDynamicVariable> fields,
		IReadOnlyList<MetadataField> metadataFields)
	{
		var found = metadataFields.FirstOrDefault(f => f.Name == fieldSchema.name.data);
		if (found == null)
		{
			var caseMismatch = metadataFields.FirstOrDefault(
				f => string.Equals(f.Name, fieldSchema.name.data, StringComparison.OrdinalIgnoreCase));
			if (caseMismatch != null)
			{
				throw new ArgumentException(
					$"Metadata field '{fieldSchema.name.data}' provided in incorrect case: '{caseMismatch.Name}'");
			}

			throw new ArgumentException($"Metadata field '{fieldSchema.name.data}' is mandatory");
		}

		var normalized = NormalizeMetadataValue(fieldSchema.schema, fieldSchema.name.data, found.Value);
		fields.Add(new VmNamedDynamicVariable
		{
			name = fieldSchema.name,
			value = normalized
		});
	}

	private static VmDynamicVariable NormalizeMetadataValue(VmVariableSchema schema, string fieldName, object? value)
	{
		if (value == null)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' is mandatory");
		}

		var isArray = (schema.type & VmType.Array) == VmType.Array;
		var baseType = isArray ? (schema.type & ~VmType.Array) : schema.type;

		if (isArray)
		{
			var arrayValue = NormalizeArrayValue(baseType, fieldName, value, schema.structure);
			return new VmDynamicVariable { type = schema.type, data = arrayValue };
		}

		var scalarValue = NormalizeScalarValue(baseType, fieldName, value, schema.structure);
		return new VmDynamicVariable { type = baseType, data = scalarValue };
	}

	private static object NormalizeScalarValue(VmType type, string fieldName, object value, VmStructSchema structSchema)
	{
		switch (type)
		{
			case VmType.String:
				return EnsureNonEmptyString(fieldName, value);
			case VmType.Int8:
				return NormalizeInt8(fieldName, value);
			case VmType.Int16:
				return NormalizeInt16(fieldName, value);
			case VmType.Int32:
				return NormalizeInt32(fieldName, value);
			case VmType.Int64:
				return NormalizeInt64(fieldName, value);
			case VmType.Int256:
				return EnsureBigInt(fieldName, value, Int256Min, Int256Max, "Int256", UInt256Max);
			case VmType.Bytes:
				return EnsureBytes(fieldName, value);
			case VmType.Bytes16:
				return EnsureBytes16(fieldName, value);
			case VmType.Bytes32:
				return EnsureBytes32(fieldName, value);
			case VmType.Bytes64:
				return EnsureBytes64(fieldName, value);
			case VmType.Struct:
				return NormalizeStructValue(fieldName, structSchema, value);
			default:
				throw new ArgumentException($"Metadata field '{fieldName}' has unsupported type '{type}'");
		}
	}

	private static object NormalizeArrayValue(VmType type, string fieldName, object value, VmStructSchema structSchema)
	{
		switch (type)
		{
			case VmType.String:
				return NormalizeStringArray(fieldName, value);
			case VmType.Int8:
				return NormalizeInt8Array(fieldName, value);
			case VmType.Int16:
				return NormalizeInt16Array(fieldName, value);
			case VmType.Int32:
				return NormalizeInt32Array(fieldName, value);
			case VmType.Int64:
				return NormalizeInt64Array(fieldName, value);
			case VmType.Int256:
				return NormalizeInt256Array(fieldName, value);
			case VmType.Bytes:
				return NormalizeBytesArray(fieldName, value);
			case VmType.Bytes16:
				return NormalizeBytes16Array(fieldName, value);
			case VmType.Bytes32:
				return NormalizeBytes32Array(fieldName, value);
			case VmType.Bytes64:
				return NormalizeBytes64Array(fieldName, value);
			case VmType.Struct:
				return NormalizeStructArray(fieldName, value, structSchema);
			default:
				throw new ArgumentException(
					$"Metadata field '{fieldName}' with type '{type}' does not support array values");
		}
	}

	private static VmDynamicStruct NormalizeStructValue(string fieldName, VmStructSchema structSchema, object value)
	{
		if (structSchema.fields == null)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' is missing struct schema");
		}

		var structFields = new List<VmNamedDynamicVariable>();
		var providedFields = MetadataStructInputToFields(fieldName, value);

		foreach (var childSchema in structSchema.fields)
		{
			var childValue = providedFields.FirstOrDefault(f => f.Name == childSchema.name.data);
			if (childValue == null)
			{
				var caseMismatch = providedFields.FirstOrDefault(
					f => string.Equals(f.Name, childSchema.name.data, StringComparison.OrdinalIgnoreCase));
				if (caseMismatch != null)
				{
					throw new ArgumentException(
						$"Metadata field '{childSchema.name.data}' provided in incorrect case inside '{fieldName}': '{caseMismatch.Name}'");
				}

				throw new ArgumentException($"Metadata field '{fieldName}.{childSchema.name.data}' is mandatory");
			}

			var normalized = NormalizeMetadataValue(
				childSchema.schema,
				$"{fieldName}.{childSchema.name.data}",
				childValue.Value);

			structFields.Add(new VmNamedDynamicVariable
			{
				name = childSchema.name,
				value = normalized
			});
		}

		var allowedNames = new HashSet<string>(
			structSchema.fields.Select(f => f.name.data.ToLowerInvariant()),
			StringComparer.Ordinal);

		foreach (var provided in providedFields)
		{
			if (!allowedNames.Contains(provided.Name.ToLowerInvariant()))
			{
				throw new ArgumentException($"Metadata field '{fieldName}' received unknown property '{provided.Name}'");
			}
		}

		return new VmDynamicStruct { fields = structFields.ToArray() };
	}

	private static VmStructArray NormalizeStructArray(string fieldName, object value, VmStructSchema structSchema)
	{
		if (structSchema.fields == null)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' is missing schema for struct elements");
		}

		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var structs = new List<VmDynamicStruct>();
		int index = 0;
		foreach (var item in items)
		{
			structs.Add(NormalizeStructValue($"{fieldName}[{index}]", structSchema, item!));
			index++;
		}

		return new VmStructArray
		{
			schema = structSchema,
			structs = structs.ToArray()
		};
	}

	private static List<MetadataField> MetadataStructInputToFields(string fieldName, object value)
	{
		if (value is IEnumerable<MetadataField> list)
		{
			return list.ToList();
		}

		if (value is IReadOnlyDictionary<string, object?> roDict)
		{
			return roDict.Select(kv => new MetadataField(kv.Key, kv.Value)).ToList();
		}

		if (value is IDictionary<string, object?> dict)
		{
			return dict.Select(kv => new MetadataField(kv.Key, kv.Value)).ToList();
		}

		if (value is IDictionary rawDict)
		{
			var fields = new List<MetadataField>();
			foreach (DictionaryEntry entry in rawDict)
			{
				if (entry.Key is not string key)
				{
					throw new ArgumentException(
						$"Metadata field '{fieldName}' must be provided as an object or array of fields");
				}
				fields.Add(new MetadataField(key, entry.Value));
			}

			return fields;
		}

		throw new ArgumentException($"Metadata field '{fieldName}' must be provided as an object or array of fields");
	}

	private static string EnsureNonEmptyString(string fieldName, object value)
	{
		if (value is not string s)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' must be a string");
		}

		if (s.Trim().Length == 0)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' is mandatory");
		}

		return s;
	}

	private static BigInteger EnsureIntegerInRange(
		string fieldName,
		object value,
		long min,
		long max,
		ulong? unsignedMax)
	{
		if (!TryGetInteger(value, out var bigintValue))
		{
			var rangeText = unsignedMax.HasValue
				? $"an integer between {min} and {max} or between 0 and {unsignedMax.Value}"
				: $"an integer between {min} and {max}";
			throw new ArgumentException($"Metadata field '{fieldName}' must be {rangeText}");
		}

		var fitsSigned = bigintValue >= min && bigintValue <= max;
		var fitsUnsigned = unsignedMax.HasValue && bigintValue >= 0 && bigintValue <= unsignedMax.Value;

		if (!fitsSigned && !fitsUnsigned)
		{
			var rangeText = unsignedMax.HasValue
				? $"between {min} and {max} or between 0 and {unsignedMax.Value}"
				: $"between {min} and {max}";
			throw new ArgumentException($"Metadata field '{fieldName}' must be {rangeText}");
		}

		return bigintValue;
	}

	private static BigInteger EnsureBigInt(
		string fieldName,
		object value,
		BigInteger min,
		BigInteger max,
		string label,
		BigInteger unsignedMax)
	{
		if (!TryGetInteger(value, out var bigintValue))
		{
			throw new ArgumentException($"Metadata field '{fieldName}' must be a bigint or a safe integer number");
		}

		var fitsSigned = bigintValue >= min && bigintValue <= max;
		var fitsUnsigned = bigintValue >= 0 && bigintValue <= unsignedMax;

		if (!fitsSigned && !fitsUnsigned)
		{
			var rangeText = $"between {min} and {max} or between 0 and {unsignedMax}";
			throw new ArgumentException($"Metadata field '{fieldName}' must be {rangeText} ({label})");
		}

		return bigintValue;
	}

	private static byte[] EnsureBytes(string fieldName, object? value)
	{
		if (value is byte[] bytes)
		{
			return bytes;
		}

		if (value is string hex)
		{
			var trimmed = hex.Trim();
			if (trimmed.Length == 0)
			{
				throw new ArgumentException($"Metadata field '{fieldName}' must be a byte array or hex string");
			}

			try
			{
				return trimmed.FromHex() ?? Array.Empty<byte>();
			}
			catch
			{
				throw new ArgumentException($"Metadata field '{fieldName}' must be a byte array or hex string");
			}
		}

		throw new ArgumentException($"Metadata field '{fieldName}' must be a byte array or hex string");
	}

	private static byte[] EnsureFixedBytes(string fieldName, object? value, int expectedLength)
	{
		var bytes = EnsureBytes(fieldName, value);
		if (bytes.Length != expectedLength)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' must be exactly {expectedLength} bytes");
		}

		return bytes;
	}

	private static Bytes16 EnsureBytes16(string fieldName, object value)
	{
		if (value is Bytes16 bytes16)
		{
			return bytes16;
		}

		return new Bytes16(EnsureFixedBytes(fieldName, value, 16));
	}

	private static Bytes32 EnsureBytes32(string fieldName, object value)
	{
		if (value is Bytes32 bytes32)
		{
			return bytes32;
		}

		return new Bytes32(EnsureFixedBytes(fieldName, value, 32));
	}

	private static Bytes64 EnsureBytes64(string fieldName, object value)
	{
		if (value is Bytes64 bytes64)
		{
			return bytes64;
		}

		return new Bytes64(EnsureFixedBytes(fieldName, value, 64));
	}

	private static IEnumerable<object?> EnumerateItems(string fieldName, object value, bool allowByteArray)
	{
		if (value is string)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' must be provided as an array");
		}

		if (!allowByteArray && value is byte[])
		{
			throw new ArgumentException($"Metadata field '{fieldName}' must be provided as an array");
		}

		if (value is IDictionary)
		{
			throw new ArgumentException($"Metadata field '{fieldName}' must be provided as an array");
		}

		if (value is IEnumerable enumerable)
		{
			foreach (var item in enumerable)
			{
				yield return item;
			}

			yield break;
		}

		throw new ArgumentException($"Metadata field '{fieldName}' must be provided as an array");
	}

	private static byte NormalizeInt8(string fieldName, object value)
	{
		var bigintValue = EnsureIntegerInRange(fieldName, value, -0x80, 0x7f, 0xff);
		return unchecked((byte)(int)bigintValue);
	}

	private static short NormalizeInt16(string fieldName, object value)
	{
		var bigintValue = EnsureIntegerInRange(fieldName, value, -0x8000, 0x7fff, 0xffff);
		if (bigintValue < 0 || bigintValue <= short.MaxValue)
		{
			return (short)bigintValue;
		}

		return unchecked((short)(ushort)bigintValue);
	}

	private static int NormalizeInt32(string fieldName, object value)
	{
		var bigintValue = EnsureIntegerInRange(fieldName, value, -0x80000000, 0x7fffffff, 0xffffffff);
		if (bigintValue < 0 || bigintValue <= int.MaxValue)
		{
			return (int)bigintValue;
		}

		return unchecked((int)(uint)bigintValue);
	}

	private static long NormalizeInt64(string fieldName, object value)
	{
		var bigintValue = EnsureBigInt(fieldName, value, Int64Min, Int64Max, "Int64", UInt64Max);
		if (bigintValue < 0 || bigintValue <= long.MaxValue)
		{
			return (long)bigintValue;
		}

		return unchecked((long)(ulong)bigintValue);
	}

	private static string[] NormalizeStringArray(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<string>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(EnsureNonEmptyString($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static byte[] NormalizeInt8Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<byte>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(NormalizeInt8($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static short[] NormalizeInt16Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<short>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(NormalizeInt16($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static int[] NormalizeInt32Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<int>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(NormalizeInt32($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static long[] NormalizeInt64Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<long>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(NormalizeInt64($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static BigInteger[] NormalizeInt256Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<BigInteger>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(EnsureBigInt($"{fieldName}[{index}]", item!, Int256Min, Int256Max, "Int256", UInt256Max));
			index++;
		}

		return result.ToArray();
	}

	private static byte[][] NormalizeBytesArray(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: false);
		var result = new List<byte[]>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(EnsureBytes($"{fieldName}[{index}]", item));
			index++;
		}

		return result.ToArray();
	}

	private static Bytes16[] NormalizeBytes16Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<Bytes16>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(EnsureBytes16($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static Bytes32[] NormalizeBytes32Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<Bytes32>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(EnsureBytes32($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static Bytes64[] NormalizeBytes64Array(string fieldName, object value)
	{
		var items = EnumerateItems(fieldName, value, allowByteArray: true);
		var result = new List<Bytes64>();
		int index = 0;
		foreach (var item in items)
		{
			result.Add(EnsureBytes64($"{fieldName}[{index}]", item!));
			index++;
		}

		return result.ToArray();
	}

	private static bool TryGetInteger(object value, out BigInteger result)
	{
		switch (value)
		{
			case byte b:
				result = b;
				return true;
			case sbyte sb:
				result = sb;
				return true;
			case short s:
				result = s;
				return true;
			case ushort us:
				result = us;
				return true;
			case int i:
				result = i;
				return true;
			case uint ui:
				result = ui;
				return true;
			case long l:
				result = l;
				return true;
			case ulong ul:
				result = ul;
				return true;
			case BigInteger bi:
				result = bi;
				return true;
			default:
				result = default;
				return false;
		}
	}
}
